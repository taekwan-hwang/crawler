==============Content================
1. [BITS 16]  -> 이문장의 의미가 궁금합니다
2.
CLS:
mov [es:bx], ax
여기에서 ex:bx가 무슨 뜻인지 모르겠습니다ㅠㅠ 
: <- 이거의 의미가 궁금합니다..



==============Comment================
[BITS 16] 는 16비트에서 동작하는 실행 코드를 만든다는 의미인고  과제 2에서 나오지만 [BITS 32]  32bit에서 동작하는 실행 코드를 만들으라는 의미 인것 같습니다.
es라는 값이 전체 코드의 윗부분을 보면 0xb80로 초기화 되있고 이 초기화점부터 bx 를 1씩 증가시키면서 최대 cx의 값이 될때 까지 반복문을 돌리며 0x00으로 초기화 시켜주기 위함입니다.
이해하기 쉽게 c로 표현하면 
for(int bx=0;bx<cx;bx++)
es+bx = ax
이런식이라 생각됩니다.

감사합니다!

혹시 최대cx까지 인건 그냥 약속되어 있는건가요?

cx(카운터 레지스터)라고 합니다.  이 cx에 저장된 값 만큼 loop가 돌게 되어있습니다.

그래서  cx에 80*25*2를 넣어주고 있습니다. 

이렇게 곱해주는 이유는 화면의 크기가 가로 80글자, 세로 25글자 이기 때문입니다. 

끝에 2를 곱해준 것도 글자가 2바이트로 표현되기 때문이죠. ( 앞은 글자 , 뒤는 글자 속성 )

구글에 부트로더와 관련된 정보를 찾아보면 부족한 부분의 정보를 얻을 수 있을 것 같습니다 .

1번은 윗분 말씀대로 16비트로 동작하는 코드라는 것을 의미하고
2번의 경우 비디오 메모리와 같은 특정 메모리 주소의 경우 20비트의 주소를 사용하는데
16비트 환경에서는 20비트를 나타낼 수 없기때문에 위 코드에서는 앞의 16비트를 es에 넣고 bx에 나머지 4비트를 나타낼 값을 넣어줌으로써 두 값을 조합해 20비트의 주소를 나타내는 방식을 사용합니다 
https://en.wikipedia.org/wiki/Intel_8086 의 segmentation 부분을 참고하시면 좋을 것 같습니다

감사합니다~

리얼모드에서 프로텍트모드로 넘어가면 : 로 cpu가 주소값을 읽는 방법이 달라지게 됩니다.  프로텍트 모드에서는 GDT 개념이 도입되면서 
기존 세그먼트 : 오프셋 방식에서 디스크립터를 참조하는 방식으로 변하게 된다고 합니다.  질문 올리신 부분은 리얼모드기 때문에 윗분들이 잘 설명해 주셨고  프로텍트 모드로 전환이후는 의미가 달라진다는거 참조하시길 바랍니다.

[reg1:reg2]는 reg1로부터 reg2만큼 떨어진 메모리를 나타낸다고 합니다.

