==============Content================
명세에 '0번 프로세스 (idle)는 schedule 함수만 계속해서 호출하도록 구현' 이라는 부분이  이해가 안가는데,
idle은 말그대로 함수일 뿐이지 않나요? 왜 프로세스라고 적혀있는지 잘 모르겠습니다. 저는 init_proc 함수에서 만들어지는 프로세스를 0번 프로세스라고 생각했습니다.

만약 idle함수가 0번째 프로세스가 맞다면 , idle 함수에 있는 " while(1) { schdule()} " 로직이 의미하는게 명세에 나온 것처럼  "0번 프로세스가 스케쥴링 프로세스를 선택하고 스케쥴링" 와 동일한 것이라고 보면 되는건가요?



==============Comment================
kernel_proc()을 1도 실행하지 않았을 때, 그러니까 kernel code만 돌아갈 때... 프로세스가 몇 개 있다고 생각하세요...? 프로세스를 어떻게 정의하느냐에 다르겠지만, 1개 실행된다고 할 수 있겠죠...? 왜냐면, 개념적으로... 프로그램의 흐름을 주도하는 어떤 주체가 있으니까요. 그게 kernel인 것이고...

idle()은 단순히 함수 맞구요, 단지 kernel이 따라가는 프로그램의 흐름이 idle()에 갇혀있는 거죠. 그러면, "kernel process는 idle()과 동치다"라고 말해도 크게 무리는 없는 거겠죠. 명세에서는 그래서 편의상 kernel을 idle()이라 부르는 거예요. 

그리고, init_proc이 만드는 프로세스, 즉 0번 프로세스는 자기 자신, kernel이잖아요. kernel 자신도 scheduling(정확히는, 전환)돼야 하는 신세니까, switch_process를 호출하기 위해 프토토콜(즉, 자기 자신을 대표하는 struct process를 만드는 것)을 따라주는 거구요.

그런데, 마지막 문단은 살짝 뉘앙스가 다른 것 같아요. 유저 프로세스에서 schedule()을 호출해도 0번 프로세스를 거쳐서 스케쥴링해라 라는 의미예요 그건.

두분다 상세히 설명해주셔서 감사합니다.  얘기해 주신 것을 정리해보면
첫번째 질문 : 데몬프로세스는 백그라운드에서 독립적으로 계속 동작하는 프로세스이며 결국 demon =  kerner process ( idle 함수 흐름) = 0 번 프로세스   로  볼 수 있는 건가요?
두번째 질문 : 0번 프로세스를 거쳐서 스케줄링 한다는 것이 결국 context switching하는 두 대상이 [0번프로세스, 스케줄링으로 선택된 프로세스] 라는 것으로 이해했습니다.

힌트는 충분히 드린 것 같습니다. 코드 직접 보시고 고민해보세요~!
EDIT:
노파심에 말씀드리는데, 2번은 before -> 0 -> after라는 말입니다.

넵 많은 도움이 되었습니다. 감사합니다

일반 리눅스도 크게 다르지 않은 것으로 알고 있지만 일반적으로 컴퓨터에 전원이 들어오고 
운영체제의 초기화 과정을 해주는 프로세스는 초기화 작업이 끝나면 daemon으로 수행되며 
스케쥴링을 해주는 프로세스로 바뀌는 것으로 알고 있습니다.
이와 같이 ssuos에서도 프로세스가 초기화 작업을 끝낸 뒤 스케쥴링을 해주는 프로세스로 작동시키기 위한 구현과정이라고 생각됩니다.
관련 내용은 리눅스에서 pid 0, 1, 2번이 생성되고 작동하는 과정을 알아보시면 좋을 것 같습니다.
+) 마지막 질문의 경우 idle이 아닌 모든 프로세스는 idle로 switch되고 
idle은 그 다음 프로세스를 선택하여 선택한 프로세스로 switch하게 구현하시면 될 것 같습니다.

