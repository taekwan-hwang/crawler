==============Content================
명세에 나와있는 예외처리를 위한 함수 get_curde() 함수를 사용하여 디렉토리 name이 기존 디렉토리와 동일하면 디렉토리를 만들 때 inode_write를 해주지 않는 방식으로 진행했습니다. 
inode_read의 경우 기존 datablock 정보를 tmpblock에 받아와 이를 리턴했습니다.(inode_write 함수에서 가장 먼저 tmpblock에 기존 정보를 받아오는 방식의 코드를 채택했습니다.)

이렇게 하면 동일 디렉토리를 생성할 때 bitmapblock과 inodeblock이 증가하지 않을 것이라 생각했는데, 계속 추가가 됩니다.
get_curde()함수로 동일 여부를 확인할 때 해당 if문으로 가지 않고 else문으로 계속 write가 되네요.

예외 처리 부분에서 제가 간과한 부분이 있다면 어떤 점을 더 생각해보는 것이 좋은가요?



==============Comment================
bitmapblock과 inodeblock이 증가하였다는게 정확히 어떤 뜻 이신가요? blk bitmap과 inode bitmap에 1이 늘어났단 이야기 이신가요? 그렇다면 mkdir시에 체크처리 전후 어디선가 이미 inode_create가 수행되어  버렸을 확률이 높은거 같습니다.

mkdir [디렉토리명] 을 입력할 때마다 bmap을 입력하여 bitmap과 inodemap이 증가했음을 확인할 수 있잖아요?
그런데 입력한 [디렉토리명]이 이전에 입력했던 디렉토리 명과 동일할 경우에는 위의 bitmap과 inodemap이 증가하면 안되는데, 즉 입력이 되지 않도록 예외처리를 해주기 위한 작업을 해주었는데, get_curde()함수를 사용한 조건문에서 계속 같은 디렉토리명을 입력해도 서로 다른 것으로 처리가되고있습니다.

아랫분 말씀대로 get_curde는 말그대로 전달한 inode의 directory entry를 가져오는 함수입니다. 이와 유사한 구조로 반대로 de의 name을 통해  있는지 여부를 확인할 수 있는 예외처리를 위한 함수나 루틴을 따로 만들어 사용하셔야 합니다.

get_curde는 예외처리가 아니라 cwd로 전달한 inode의 디렉토리 이름과  inode 번호를 de라는 구조체에 가져오는 함수인데
이를 이용해서 어떻게 예외처리는 하신지는 모르겟지만 함수 사용을 잘못 사용하신것같습니다.

확인했습니다. get_curde함수의 사용 용도를 잘못 분석했던것 같습니다.

